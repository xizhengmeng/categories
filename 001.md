## 关于计算机科学
- 计算机科学的本质是计算科学
- 如果我们想要对一个事物进行改善，那么我们必须能够测量它
- ’Data Structures and Algorithms‘我们简称数据结构和算法为DSA

### 什么是算法
- 输入：待处理信息，问题
- 输出：经处理的信息，答案
- 正确性：的确可以解决指定的问题
- 确定性：任一算法都可以描述为一个由基本操作组成的序列
- 可行性：每一基本操作都可以实现，并且在常数时间内完成
- 有穷性：任何输入经过又穷次的输入都要有输出，返回退出，所以我们就有一个**结论程序未必是算法**，因为我们经常会得到死循环或者栈溢出

>算法最重要的是速度尽可能快，存储空间尽量少

### 关于程序
所有的程序都要有三种语句：
1. 条件判断语句
2. 转向语句
3. stop语句

有三个状态：
1. 初始化状态
2. 运行状态
3. 终止状态

有一些事物在你不使用的时候，它并不会消失，这个时候一定要记得改变它的状态到，初始化状态，方便后边再次使用

### 大O记号
- 复杂度分析的尺度
- 关心足够大的问题，并且是成本的<font color = red>增长趋势</font>
- 考察的内容
  - 需要执行的基本操作次数，<font color = blue>注意这是对时间的成本的转换，将时间用基本操作的次数来表示</font>
  - 需要占用的存储单元的规模
- T(n) = O(f(n))，我们的处理方法就是对n不断的做放大操作进而得到近似的表达式，只要该表达式可以反映当前的增长趋势即可
  - 5n*(3n*(n+2) + 4) + 6 = 5n*(3n*(n+n) + 4) + 6 = 5n*(3n*2*n + 4) + 6 = 5n*($$6n^2$$ + 4) + 6 = 5n*($$6n^2$$ + $$n^2$$) + 6 = $$35n^3$$ + 6 = $$35n^3$$ + $$n^3$$ = $$36*n^3$$ = $$n^3$$
- 我们可以得到大O记号的处理规则
  - 常数系数可以忽略
  - 低次项可忽略
- 那些刻度
  - O(1)，常数复杂度：顺序执行，不包含循环，递归
  - O(logn)
  - O($$n^c$$)，多项式复杂度
  - O($$2^n$$)，这种复杂度是可以完全覆盖多项式复杂度
- 从O($$n^c$$)到O($$2^n$$)是有效算法到无效算法的分水岭，很多时候O($$2^n$$)的算法实现显而易见，但是这是没有意义的，因为复杂度太高，不会有结果的

### 算法分析
- 分析一个算法最简单的做法是首先忽略掉空间，只关注时间，概括而言问题实例的规模往往是计算成本的主要因素，<font color=red>规模越大计算成本越大</font>，但是知道这个并没有实际的意义，我们需要更准确的测量结果。
- 那么针对同一个问题的不同算法，如何评价优劣呢？最简单的做法是实验统计方法，但是不能反应真正的效率因为：
  - 不同算法可能更适用不同的规模的输入
  - 不算算法可能更适用于不同类型的输入
  - 不同的编程语言
  - 不同的体系结构和操作系统
- 所以我们需要抽象出一个理想的模型
- 基本原则就是去粗存精
- 算法分析的两个任务
  - 正确性，不变性和单调性
  - 复杂度
- 复杂度分析的主要方法
  - 迭代：级数求和
  - 递归：递归追踪+递归方程
  - 猜测+验证
#### 级数分析
